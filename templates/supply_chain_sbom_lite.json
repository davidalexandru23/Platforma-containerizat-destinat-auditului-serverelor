{
    "$schema": "bittrail-template@1.0",
    "metadata": {
        "name": "Supply Chain & SBOM Readiness (SLSA-lite) - Linux + Docker",
        "description": "Template orientat pe supply chain software si SBOM readiness (SLSA-lite): inventar pachete, integritate repo-uri, postura de patching, politici pentru containere (latest, digest pinning), semne de repo-uri nesigure si hygiene (keys/ssh). Verificarile sunt implementate ca COMMAND checks (bash) pentru compatibilitate cu agentul actual.",
        "version": "1.1.0",
        "type": "SUPPLY_CHAIN",
        "author": "BitTrail Platform",
        "createdAt": "2026-01-27T00:00:00Z"
    },
    "controls": [
        {
            "controlId": "SC-1",
            "title": "SBOM-lite: Baza sistemului (OS + pachete)",
            "category": "SUPPLY_CHAIN",
            "severity": "MEDIUM",
            "automatedChecks": [
                {
                    "checkId": "SC-1.1",
                    "title": "Detecteaza distributia (os-release)",
                    "command": "if [ -f /etc/os-release ]; then . /etc/os-release; echo \"OS=$PRETTY_NAME\"; echo 'CHECK=PASS'; else echo 'CHECK=FAIL'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                },
                {
                    "checkId": "SC-1.2",
                    "title": "Inventar pachete (dpkg sau rpm)",
                    "command": "if command -v dpkg-query >/dev/null 2>&1; then COUNT=$(dpkg-query -W 2>/dev/null | wc -l); echo \"PKG_MGR=dpkg\"; echo \"PACKAGE_COUNT=$COUNT\"; elif command -v rpm >/dev/null 2>&1; then COUNT=$(rpm -qa 2>/dev/null | wc -l); echo \"PKG_MGR=rpm\"; echo \"PACKAGE_COUNT=$COUNT\"; else COUNT=0; echo 'PKG_MGR=NONE'; fi; if [ \"$COUNT\" -gt 0 ] 2>/dev/null; then echo 'CHECK=PASS'; else echo 'CHECK=FAIL'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                },
                {
                    "checkId": "SC-1.3",
                    "title": "Package manager disponibil (apt/dnf/yum)",
                    "command": "FOUND=''; command -v apt >/dev/null 2>&1 && FOUND=\"$FOUND apt\"; command -v dnf >/dev/null 2>&1 && FOUND=\"$FOUND dnf\"; command -v yum >/dev/null 2>&1 && FOUND=\"$FOUND yum\"; if [ -n \"$FOUND\" ]; then echo \"PKG_MANAGERS=$FOUND\"; echo 'CHECK=PASS'; else echo 'PKG_MANAGERS=NONE'; echo 'CHECK=FAIL'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                }
            ],
            "manualChecks": [
                {
                    "checkId": "SC-1.M1",
                    "title": "Politica SBOM: exista proces documentat de generare SBOM pentru aplicatii (nu doar OS)",
                    "instructions": "Confirmati daca exista o procedura/standard intern (ex: CycloneDX/SPDX) pentru generarea SBOM la build/deploy.",
                    "evidenceSpec": {
                        "allowUpload": true,
                        "allowLink": true
                    }
                }
            ]
        },
        {
            "controlId": "SC-2",
            "title": "Repository Integrity: surse oficiale, TLS, semnaturi",
            "category": "SUPPLY_CHAIN",
            "severity": "HIGH",
            "automatedChecks": [
                {
                    "checkId": "SC-2.1",
                    "title": "Repo-uri APT pe HTTP (nesigur)",
                    "command": "if [ -d /etc/apt ]; then HTTP_REPOS=$(grep -RhoE '^[[:space:]]*deb[[:space:]]+http://[^[:space:]]+' /etc/apt/sources.list /etc/apt/sources.list.d/*.list 2>/dev/null | wc -l); echo \"HTTP_REPOS=$HTTP_REPOS\"; if [ \"$HTTP_REPOS\" -eq 0 ]; then echo 'CHECK=PASS'; else echo 'CHECK=FAIL'; fi; else echo 'APT=NOT_PRESENT'; echo 'CHECK=PASS'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                },
                {
                    "checkId": "SC-2.2",
                    "title": "Third-party repo-uri inventar",
                    "command": "if [ -d /etc/apt/sources.list.d ]; then THIRD_PARTY=$(ls -1 /etc/apt/sources.list.d 2>/dev/null | wc -l); echo \"THIRD_PARTY_REPOS=$THIRD_PARTY\"; ls -1 /etc/apt/sources.list.d 2>/dev/null; echo 'CHECK=PASS'; else echo 'APT=NOT_PRESENT'; echo 'CHECK=PASS'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                },
                {
                    "checkId": "SC-2.3",
                    "title": "APT signed-by keyrings (best practice)",
                    "command": "if [ -f /etc/apt/sources.list ] || [ -d /etc/apt/sources.list.d ]; then SIGNED=$(grep -RhoE 'signed-by=' /etc/apt/sources.list /etc/apt/sources.list.d/*.list 2>/dev/null | wc -l); echo \"SIGNED_BY_REFS=$SIGNED\"; if [ \"$SIGNED\" -gt 0 ]; then echo 'CHECK=PASS'; else echo 'CHECK=WARN'; fi; else echo 'APT=NOT_PRESENT'; echo 'CHECK=PASS'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                },
                {
                    "checkId": "SC-2.4",
                    "title": "Keyrings directory exists",
                    "command": "if [ -d /etc/apt/keyrings ]; then echo 'KEYRINGS_DIR=EXISTS'; echo 'CHECK=PASS'; elif [ -d /etc/apt ]; then echo 'KEYRINGS_DIR=MISSING'; echo 'CHECK=WARN'; else echo 'APT=NOT_PRESENT'; echo 'CHECK=PASS'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                },
                {
                    "checkId": "SC-2.5",
                    "title": "DNF/YUM GPGcheck activ",
                    "command": "if command -v dnf >/dev/null 2>&1; then GPGCHECK=$(grep -E '^gpgcheck' /etc/dnf/dnf.conf 2>/dev/null | cut -d= -f2); echo \"DNF_GPGCHECK=$GPGCHECK\"; if [ \"$GPGCHECK\" = '1' ]; then echo 'CHECK=PASS'; else echo 'CHECK=WARN'; fi; elif command -v yum >/dev/null 2>&1; then GPGCHECK=$(grep -E '^gpgcheck' /etc/yum.conf 2>/dev/null | cut -d= -f2); echo \"YUM_GPGCHECK=$GPGCHECK\"; if [ \"$GPGCHECK\" = '1' ]; then echo 'CHECK=PASS'; else echo 'CHECK=WARN'; fi; else echo 'DNF_YUM=NOT_PRESENT'; echo 'CHECK=PASS'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                }
            ],
            "manualChecks": [
                {
                    "checkId": "SC-2.M1",
                    "title": "Lista repo-uri aprobate",
                    "instructions": "Exista o lista aprobata de repo-uri (oficiale + third-party) si un proces de review pentru adaugare?",
                    "evidenceSpec": {
                        "allowUpload": true,
                        "allowLink": true
                    }
                }
            ]
        },
        {
            "controlId": "SC-3",
            "title": "Patching & Update Posture: reduceri risc vulnerabilitati supply chain",
            "category": "SUPPLY_CHAIN",
            "severity": "HIGH",
            "automatedChecks": [
                {
                    "checkId": "SC-3.1",
                    "title": "Pending updates count",
                    "command": "if command -v apt >/dev/null 2>&1; then UPGRADABLE=$(apt list --upgradable 2>/dev/null | tail -n +2 | wc -l); echo \"PENDING_UPDATES=$UPGRADABLE\"; if [ \"$UPGRADABLE\" -le 50 ]; then echo 'CHECK=PASS'; else echo 'CHECK=WARN'; fi; elif command -v dnf >/dev/null 2>&1; then COUNT=$(dnf -q check-update 2>/dev/null | grep -c '.'); echo \"PENDING_UPDATES=$COUNT\"; if [ \"$COUNT\" -le 50 ]; then echo 'CHECK=PASS'; else echo 'CHECK=WARN'; fi; else echo 'SKIP'; echo 'CHECK=PASS'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                },
                {
                    "checkId": "SC-3.2",
                    "title": "Unattended upgrades instalat (Debian/Ubuntu)",
                    "command": "if command -v dpkg-query >/dev/null 2>&1; then if dpkg-query -W unattended-upgrades >/dev/null 2>&1; then echo 'UNATTENDED_UPGRADES=INSTALLED'; echo 'CHECK=PASS'; else echo 'UNATTENDED_UPGRADES=MISSING'; echo 'CHECK=FAIL'; fi; else echo 'NOT_DEBIAN'; echo 'CHECK=PASS'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                },
                {
                    "checkId": "SC-3.3",
                    "title": "Unattended upgrades config activ",
                    "command": "if [ -f /etc/apt/apt.conf.d/20auto-upgrades ]; then if grep -qE 'APT::Periodic::Unattended-Upgrade\\s+\"1\"' /etc/apt/apt.conf.d/20auto-upgrades 2>/dev/null; then echo 'AUTO_UPGRADE=ACTIVE'; echo 'CHECK=PASS'; else echo 'AUTO_UPGRADE=NOT_SET'; echo 'CHECK=FAIL'; fi; else echo 'AUTO_UPGRADE=MISSING'; echo 'CHECK=WARN'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                },
                {
                    "checkId": "SC-3.4",
                    "title": "Reboot required detection",
                    "command": "if [ -f /var/run/reboot-required ]; then echo 'REBOOT_REQUIRED=YES'; echo 'CHECK=WARN'; else echo 'REBOOT_REQUIRED=NO'; echo 'CHECK=PASS'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                }
            ],
            "manualChecks": [
                {
                    "checkId": "SC-3.M1",
                    "title": "Fereastra de patching si SLA",
                    "instructions": "Care este SLA-ul pentru aplicarea patch-urilor critice? Ex: 7/14/30 zile.",
                    "evidenceSpec": {
                        "allowUpload": true,
                        "allowLink": true
                    }
                }
            ]
        },
        {
            "controlId": "SC-4",
            "title": "Container Supply Chain: imagini, taguri, digest pinning, registries",
            "category": "SUPPLY_CHAIN",
            "severity": "HIGH",
            "automatedChecks": [
                {
                    "checkId": "SC-4.1",
                    "title": "Docker installed",
                    "command": "if command -v docker >/dev/null 2>&1; then echo 'DOCKER=INSTALLED'; docker --version 2>/dev/null; echo 'CHECK=PASS'; else echo 'DOCKER=NOT_INSTALLED'; echo 'CHECK=PASS'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                },
                {
                    "checkId": "SC-4.2",
                    "title": "Docker daemon accesibil",
                    "command": "if command -v docker >/dev/null 2>&1; then if docker ps >/dev/null 2>&1; then echo 'DOCKER_DAEMON=ACCESSIBLE'; echo 'CHECK=PASS'; else echo 'DOCKER_DAEMON=NOT_ACCESSIBLE'; echo 'CHECK=WARN'; fi; else echo 'DOCKER=NOT_INSTALLED'; echo 'CHECK=PASS'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                },
                {
                    "checkId": "SC-4.3",
                    "title": "Running containers inventory",
                    "command": "if command -v docker >/dev/null 2>&1 && docker ps >/dev/null 2>&1; then CONTAINERS=$(docker ps -q 2>/dev/null | wc -l); IMAGES=$(docker images -q 2>/dev/null | wc -l); echo \"RUNNING_CONTAINERS=$CONTAINERS\"; echo \"IMAGES=$IMAGES\"; echo 'CHECK=PASS'; else echo 'DOCKER=NOT_AVAILABLE'; echo 'CHECK=PASS'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                },
                {
                    "checkId": "SC-4.4",
                    "title": "Detectie tag :latest in containere active",
                    "command": "if command -v docker >/dev/null 2>&1 && docker ps >/dev/null 2>&1; then LATEST_COUNT=$(docker ps --format '{{.Image}}' 2>/dev/null | grep -cE ':latest$'); echo \"LATEST_TAG_CONTAINERS=$LATEST_COUNT\"; if [ \"$LATEST_COUNT\" -eq 0 ]; then echo 'CHECK=PASS'; else echo 'CHECK=FAIL'; docker ps --format '{{.Image}}' 2>/dev/null | grep -E ':latest$'; fi; else echo 'DOCKER=NOT_AVAILABLE'; echo 'CHECK=PASS'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                },
                {
                    "checkId": "SC-4.5",
                    "title": "Imagini fara digest pinning",
                    "command": "if command -v docker >/dev/null 2>&1 && docker ps >/dev/null 2>&1; then UNPINNED=$(docker ps -q 2>/dev/null | while read -r id; do docker inspect --format '{{json .RepoDigests}}' \"$id\" 2>/dev/null; done | grep -c '\\[\\]'); echo \"UNPINNED_IMAGES=$UNPINNED\"; if [ \"$UNPINNED\" -eq 0 ]; then echo 'CHECK=PASS'; else echo 'CHECK=WARN'; fi; else echo 'DOCKER=NOT_AVAILABLE'; echo 'CHECK=PASS'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                },
                {
                    "checkId": "SC-4.6",
                    "title": "Non-standard registries in use",
                    "command": "if command -v docker >/dev/null 2>&1 && docker ps >/dev/null 2>&1; then REGISTRIES=$(docker ps --format '{{.Image}}' 2>/dev/null | awk -F/ 'NF>1{print $1}' | grep -E '\\.' | sort -u); if [ -n \"$REGISTRIES\" ]; then echo \"CUSTOM_REGISTRIES=$REGISTRIES\"; echo 'CHECK=REVIEW'; else echo 'CUSTOM_REGISTRIES=NONE'; echo 'CHECK=PASS'; fi; else echo 'DOCKER=NOT_AVAILABLE'; echo 'CHECK=PASS'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                }
            ],
            "manualChecks": [
                {
                    "checkId": "SC-4.M1",
                    "title": "Politica imagini: aprobate, scanate, semnate",
                    "instructions": "Exista politica de folosire imagini (registries permise), scanning (SCA), si/sau semnare (cosign/notary)?",
                    "evidenceSpec": {
                        "allowUpload": true,
                        "allowLink": true
                    }
                },
                {
                    "checkId": "SC-4.M2",
                    "title": "Build pipeline: provenienta imagini",
                    "instructions": "Imaginile sunt construite intern (CI) sau luate direct din public registries? Exista review + locking (digest)?",
                    "evidenceSpec": {
                        "allowUpload": true,
                        "allowLink": true
                    }
                }
            ]
        },
        {
            "controlId": "SC-5",
            "title": "Source of Truth & Git hygiene (server-side indicators)",
            "category": "SUPPLY_CHAIN",
            "severity": "MEDIUM",
            "automatedChecks": [
                {
                    "checkId": "SC-5.1",
                    "title": "Git installed",
                    "command": "if command -v git >/dev/null 2>&1; then echo 'GIT=INSTALLED'; git --version 2>/dev/null; echo 'CHECK=PASS'; else echo 'GIT=MISSING'; echo 'CHECK=WARN'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                },
                {
                    "checkId": "SC-5.2",
                    "title": "Git checkouts on server",
                    "command": "GIT_DIRS=$(find / -maxdepth 4 -type d -name .git 2>/dev/null | wc -l); echo \"GIT_CHECKOUTS=$GIT_DIRS\"; if [ \"$GIT_DIRS\" -eq 0 ]; then echo 'CHECK=PASS'; else echo 'CHECK=REVIEW'; find / -maxdepth 4 -type d -name .git 2>/dev/null | head -n 10; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                },
                {
                    "checkId": "SC-5.3",
                    "title": "Exposed private keys",
                    "command": "KEYS=$(find /etc /home /root -maxdepth 4 -type f \\( -name 'id_rsa' -o -name '*_key' \\) 2>/dev/null | wc -l); echo \"EXPOSED_PRIVATE_KEYS=$KEYS\"; if [ \"$KEYS\" -eq 0 ]; then echo 'CHECK=PASS'; else echo 'CHECK=WARN'; find /etc /home /root -maxdepth 4 -type f \\( -name 'id_rsa' -o -name '*_key' \\) 2>/dev/null | head -n 10; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                }
            ],
            "manualChecks": [
                {
                    "checkId": "SC-5.M1",
                    "title": "Politica de deployment: interzis build pe server (snowflake)",
                    "instructions": "Confirmati ca build-urile se fac in CI/CD si nu direct pe server, si ca exista un proces de promovare (dev->staging->prod).",
                    "evidenceSpec": {
                        "allowUpload": true,
                        "allowLink": true
                    }
                }
            ]
        },
        {
            "controlId": "SC-6",
            "title": "SLSA-lite: Controale minime de integritate si hardening legate de supply chain",
            "category": "SUPPLY_CHAIN",
            "severity": "HIGH",
            "automatedChecks": [
                {
                    "checkId": "SC-6.1",
                    "title": "SSH PasswordAuthentication dezactivat",
                    "command": "VALUE=$(sshd -T 2>/dev/null | grep -i 'passwordauthentication' | awk '{print $2}'); if [ -z \"$VALUE\" ]; then VALUE=$(grep -Ei '^[[:space:]]*PasswordAuthentication' /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}'); fi; echo \"PasswordAuthentication=$VALUE\"; if echo \"$VALUE\" | grep -qi 'no'; then echo 'CHECK=PASS'; else echo 'CHECK=FAIL'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                },
                {
                    "checkId": "SC-6.2",
                    "title": "SSH PermitRootLogin dezactivat",
                    "command": "VALUE=$(sshd -T 2>/dev/null | grep -i 'permitrootlogin' | awk '{print $2}'); if [ -z \"$VALUE\" ]; then VALUE=$(grep -Ei '^[[:space:]]*PermitRootLogin' /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}'); fi; echo \"PermitRootLogin=$VALUE\"; if echo \"$VALUE\" | grep -qiE '^(no|prohibit-password)$'; then echo 'CHECK=PASS'; else echo 'CHECK=FAIL'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                },
                {
                    "checkId": "SC-6.3",
                    "title": "Firewall activ",
                    "command": "if command -v ufw >/dev/null 2>&1; then STATUS=$(ufw status 2>/dev/null | head -1); echo \"$STATUS\"; if echo \"$STATUS\" | grep -qi 'active'; then echo 'FIREWALL=ACTIVE'; echo 'CHECK=PASS'; else echo 'FIREWALL=INACTIVE'; echo 'CHECK=FAIL'; fi; elif command -v firewall-cmd >/dev/null 2>&1; then if firewall-cmd --state 2>/dev/null | grep -qi 'running'; then echo 'FIREWALL=ACTIVE'; echo 'CHECK=PASS'; else echo 'FIREWALL=INACTIVE'; echo 'CHECK=FAIL'; fi; elif command -v nft >/dev/null 2>&1; then RULES=$(nft list ruleset 2>/dev/null | wc -l); if [ \"$RULES\" -gt 2 ]; then echo 'FIREWALL=ACTIVE'; echo 'CHECK=PASS'; else echo 'FIREWALL=INACTIVE'; echo 'CHECK=FAIL'; fi; else echo 'FIREWALL=NOT_FOUND'; echo 'CHECK=FAIL'; fi",
                    "expectedResult": "CHECK=PASS",
                    "comparison": "CONTAINS",
                    "checkType": "COMMAND"
                }
            ],
            "manualChecks": [
                {
                    "checkId": "SC-6.M1",
                    "title": "Control acces la repo-uri/pipeline",
                    "instructions": "Review: MFA obligatoriu pe Git/Registry? Rotatie token-uri? Least privilege pentru deploy keys?",
                    "evidenceSpec": {
                        "allowUpload": true,
                        "allowLink": true
                    }
                },
                {
                    "checkId": "SC-6.M2",
                    "title": "Semnare artefacte",
                    "instructions": "Exista semnare pentru release-uri / pachete / imagini (GPG/cosign)? Daca nu, justificare si plan.",
                    "evidenceSpec": {
                        "allowUpload": true,
                        "allowLink": true
                    }
                }
            ]
        }
    ]
}